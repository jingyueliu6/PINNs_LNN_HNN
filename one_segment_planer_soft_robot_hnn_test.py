import jax.numpy as jnp
import jax
from functools import partial
from scipy.integrate import odeint
import numpy as np
import matplotlib.pyplot as plt
import pickle
import haiku as hk
import HNN_model as hnn
import os

dir_path = os.path.dirname(os.path.realpath(__file__))


## give a random and reasonable initial state to test
init_state = np.array([-1.0, -0.5, -0.2, 0.2])
total_time = 10.0
time_step = 0.02
# time_step = 0.05
t = np.arange(0, total_time, time_step)
n = t.shape[0]

## give some random and reasonable input to test
u = np.ones(n) + 3.2 * np.pi


def rk4_step(f, x, y, t, h):
    # one step of runge-kutta integration
    k1 = h * f(x, y, t)
    k2 = h * f(x + k1/2, y, t + h/2)
    k3 = h * f(x + k2/2, y, t + h/2)
    k4 = h * f(x + k3, y, t + h)
    return x + 1/6 * (k1 + 2 * k2 + 2 * k3 + k4)


def equation_of_motion(state, u, t):
    th, dL, pth, pL = state
    th += 1.e-7 # to avoid singularity problem
    ## this eqution is generated by matlab
    dth = -(3*th**4*(2*pL*th + 2*pth*th**2 - 3*pL*np.sin(th) - 3*dL*pL*np.sin(th) + pL*th*np.cos(th) - 2*pth*th*np.sin(th) + 2*dL*pL*th + dL*pL*th*np.cos(th)))/((dL**2 + 2*dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th)))
    ddL = -(th**3*(pL*th**3 + 6*pth*th**2 + dL*pL*th**3 - 9*pth*th*np.sin(th) - 24*pL*np.cos(th/2)*np.sin(th/2) + 3*pth*th**2*np.cos(th) + 12*pL*th*np.cos(th/2)**2 + 12*dL*pL*th*np.cos(th/2)**2 - 24*dL*pL*np.cos(th/2)*np.sin(th/2)))/((dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th)))
    dpth = u - 10*th - (981*(2*dL - 2*np.cos(th) - 2*dL*np.cos(th) + 2))/(100*th**3) + (981*(2*np.sin(th) + 2*dL*np.sin(th)))/(200*th**2) + (3*th**4*(2*pL*th + 2*pth*th**2 - 3*pL*np.sin(th) - 3*dL*pL*np.sin(th) + pL*th*np.cos(th) - 2*pth*th*np.sin(th) + 2*dL*pL*th + dL*pL*th*np.cos(th)))/(5*(dL**2 + 2*dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) + (pL*th**3*(3*th**2*np.cos(th) - 9*th*np.sin(th) + 6*th**2))/(5*(dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) + (3*pL*th**2*(pL*th**3 + 6*pth*th**2 + dL*pL*th**3 - 9*pth*th*np.sin(th) - 24*pL*np.cos(th/2)*np.sin(th/2) + 3*pth*th**2*np.cos(th) + 12*pL*th*np.cos(th/2)**2 + 12*dL*pL*th*np.cos(th/2)**2 - 24*dL*pL*np.cos(th/2)*np.sin(th/2)))/(2*(dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) - (3*pth*th**4*(2*th*np.sin(th) - 2*th**2))/(5*(dL**2 + 2*dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) + (6*pth*th**3*(2*pL*th + 2*pth*th**2 - 3*pL*np.sin(th) - 3*dL*pL*np.sin(th) + pL*th*np.cos(th) - 2*pth*th*np.sin(th) + 2*dL*pL*th + dL*pL*th*np.cos(th)))/((dL**2 + 2*dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) + (pL*th**3*(12*pth*th + 12*pL*np.sin(th/2)**2 + 3*pL*th**2 - 9*pth*np.sin(th) + 3*dL*pL*th**2 - 3*pth*th*np.cos(th) - 3*pth*th**2*np.sin(th) + 12*dL*pL*np.sin(th/2)**2 - 12*pL*th*np.cos(th/2)*np.sin(th/2) - 12*dL*pL*th*np.cos(th/2)*np.sin(th/2)))/(2*(dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) - (3*pth*th**4*(2*pL*np.cos(th) - 2*dL*pL - 4*pth*th - 2*pL + 2*pth*np.sin(th) + 2*dL*pL*np.cos(th) + 2*pth*th*np.cos(th) + pL*th*np.sin(th) + dL*pL*th*np.sin(th)))/(2*(dL**2 + 2*dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) + (pL*th**3*(pL*th**3 + 6*pth*th**2 + dL*pL*th**3 - 9*pth*th*np.sin(th) - 24*pL*np.cos(th/2)*np.sin(th/2) + 3*pth*th**2*np.cos(th) + 12*pL*th*np.cos(th/2)**2 + 12*dL*pL*th*np.cos(th/2)**2 - 24*dL*pL*np.cos(th/2)*np.sin(th/2))*(36*np.sin(th) - 24*th + 12*th*np.cos(th)**2 - 2*th**3*np.cos(th) - 18*th*np.sin(th)**2 + 6*th**2*np.sin(th) - 36*np.cos(th)*np.sin(th) + 24*th*np.cos(th/2)**2 + 24*th*np.sin(th/2)**2 + 12*th*np.cos(th) + 8*th**3 - 48*np.cos(th/2)*np.sin(th/2) - 24*np.sin(th/2)**2*np.sin(th) - 24*th*np.cos(th/2)**2*np.cos(th) - 24*th**2*np.cos(th/2)*np.sin(th/2) + 48*np.cos(th/2)*np.sin(th/2)*np.cos(th) + 6*th**2*np.cos(th)*np.sin(th) + 24*th*np.cos(th/2)*np.sin(th/2)*np.sin(th)))/(2*(dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))**2) + (3*pth*th**4*(2*pL*th + 2*pth*th**2 - 3*pL*np.sin(th) - 3*dL*pL*np.sin(th) + pL*th*np.cos(th) - 2*pth*th*np.sin(th) + 2*dL*pL*th + dL*pL*th*np.cos(th))*(36*np.sin(th) - 24*th + 12*th*np.cos(th)**2 - 2*th**3*np.cos(th) - 18*th*np.sin(th)**2 + 6*th**2*np.sin(th) - 36*np.cos(th)*np.sin(th) + 24*th*np.cos(th/2)**2 + 24*th*np.sin(th/2)**2 + 12*th*np.cos(th) + 8*th**3 - 48*np.cos(th/2)*np.sin(th/2) - 24*np.sin(th/2)**2*np.sin(th) - 24*th*np.cos(th/2)**2*np.cos(th) - 24*th**2*np.cos(th/2)*np.sin(th/2) + 48*np.cos(th/2)*np.sin(th/2)*np.cos(th) + 6*th**2*np.cos(th)*np.sin(th) + 24*th*np.cos(th/2)*np.sin(th/2)*np.sin(th)))/(2*(dL**2 + 2*dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))**2)
    dpL = (th**3*(pL*th**3 + 6*pth*th**2 + dL*pL*th**3 - 9*pth*th*np.sin(th) - 24*pL*np.cos(th/2)*np.sin(th/2) + 3*pth*th**2*np.cos(th) + 12*pL*th*np.cos(th/2)**2 + 12*dL*pL*th*np.cos(th/2)**2 - 24*dL*pL*np.cos(th/2)*np.sin(th/2)))/(5*(dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) - (981*(2*np.cos(th) - 2))/(200*th**2) - 10*dL - (pL*th**3*(pL*th**3 + 6*pth*th**2 + dL*pL*th**3 - 9*pth*th*np.sin(th) - 24*pL*np.cos(th/2)*np.sin(th/2) + 3*pth*th**2*np.cos(th) + 12*pL*th*np.cos(th/2)**2 + 12*dL*pL*th*np.cos(th/2)**2 - 24*dL*pL*np.cos(th/2)*np.sin(th/2)))/(2*(dL + 1)**2*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) + (3*pth*th**4*(2*pL*th - 3*pL*np.sin(th) + pL*th*np.cos(th)))/(2*(dL**2 + 2*dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) + (pL*th**3*(12*th*np.cos(th/2)**2 + dL*th**3 + th**3 - 24*np.cos(th/2)*np.sin(th/2) - 24*dL*np.cos(th/2)*np.sin(th/2) + 12*dL*th*np.cos(th/2)**2))/(5*(dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) + (pL*th**3*(pL*th**3 - 24*pL*np.cos(th/2)*np.sin(th/2) + 12*pL*th*np.cos(th/2)**2))/(2*(dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) + (3*pth*th**4*(2*th - 3*np.sin(th) + 2*dL*th - 3*dL*np.sin(th) + th*np.cos(th) + dL*th*np.cos(th)))/(5*(dL**2 + 2*dL + 1)*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th))) - (3*pth*th**4*(2*dL + 2)*(2*pL*th + 2*pth*th**2 - 3*pL*np.sin(th) - 3*dL*pL*np.sin(th) + pL*th*np.cos(th) - 2*pth*th*np.sin(th) + 2*dL*pL*th + dL*pL*th*np.cos(th)))/(2*(dL**2 + 2*dL + 1)**2*(12*th**2*np.cos(th) + 2*th**3*np.sin(th) + 27*np.sin(th)**2 + 3*th**2*np.cos(th)**2 - 36*th*np.sin(th) - 24*th**2*np.cos(th/2)**2 + 12*th**2 - 2*th**4 + 48*th*np.cos(th/2)*np.sin(th/2) + 24*th*np.cos(th/2)**2*np.sin(th) - 18*th*np.cos(th)*np.sin(th) - 48*np.cos(th/2)*np.sin(th/2)*np.sin(th)))
    return np.stack([dth, ddL, dpth, dpL])

state_transformation_fn = partial(rk4_step, equation_of_motion, t=0.0, h = time_step)


states_real = []
state = init_state
for i in range(n):
    states_real.append(state)
    state = state_transformation_fn(state, u[i])
states_real = np.array(states_real)

with open(f"./models/one_segment_planer_soft_robot_hnn.jax", 'rb') as f:
    data = pickle.load(f)

hyper = data["hyper"]
params = data["params"]

activations = {
    'tanh': jnp.tanh,
    'softplus': jax.nn.softplus,
    'sigmoid': jax.nn.sigmoid,
}

hamiltonian_fn = hk.transform(partial(
    hnn.structured_hamiltonian_fn,
    n_dof=hyper['n_dof'],
    shape=(hyper['n_width'],) * hyper['n_depth'],
    activation=activations[hyper['activation1']],
    epsilon=hyper['diagonal_epsilon'],
    shift=hyper['diagonal_shift'],
))

#def dissipative_matrix(p, n_dof, shape, activation)
dissipative_fn = hk.transform(partial(
    hnn.dissipative_matrix,
    n_dof=hyper['n_dof'],
    shape=(hyper['n_width'],) * hyper['n_depth'],
    activation=activations[hyper['activation1']]
))

# def input_transform_matrix(q, n_dof, actuator_dof, shape, activation):
input_mat_fn = hk.transform(partial(
    hnn.input_transform_matrix,
    n_dof=hyper['n_dof'],
    actuator_dof= 1,
    shape=(4,) * 3,
    activation=activations[hyper['activation1']]
))


hamiltonian = hamiltonian_fn.apply
dissipative_mat = dissipative_fn.apply
input_mat = input_mat_fn.apply
# input_mat = np.array([[1.], [-1.0e-2]])

feed_forward_model =jax.jit(hnn.forward_model(params=params, key=None, hamiltonian=hamiltonian, dissipative_mat=dissipative_mat, input_mat=input_mat))

state = init_state
states =[]
u = u.reshape(-1, 1)
for i in range(n):
    states.append(state)
    state = partial(rk4_step, feed_forward_model, t=0.0, h=time_step)(state, u[i])

states = np.array(states)

font1 = {'weight': 'normal',
         'size': 8,
         }

plt.subplot(1, 2, 1)
plt.plot(t, states_real[:, 0], 'g', alpha=0.5, linewidth=2, label='real_theta')
plt.plot(t, states[:, 0], 'g', ls='--', linewidth=1, label='pred_theta')
plt.plot(t, states_real[:, 1], 'r', alpha=0.5,  linewidth=2, label='real_dL')
plt.plot(t, states[:, 1], 'r',  ls='--', linewidth=1, label='pred_dL')
plt.legend(fontsize=7, loc='upper right')
plt.ylabel("position")
plt.xlabel('time[s]')
plt.title(f'Initial_State: theta ({init_state[0]:.1e}), dL ({init_state[1]:.1e})', fontdict=font1)
plt.subplot(1, 2, 2)
plt.plot(t, states_real[:, 2], 'm', alpha=0.5, linewidth=2, label='real_angular_momentum')
plt.plot(t, states[:, 2], 'm', ls='--', linewidth=1, label='pred_angular_momentum')
plt.plot(t, states_real[:, 3], 'b', alpha=0.5,  linewidth=2, label='real_dL_momentum')
plt.plot(t, states[:, 3], 'b',  ls='--', linewidth=1, label='pred_dL_momentum')
plt.legend(fontsize=7, loc='upper right')
plt.ylabel("velocity")
plt.xlabel('time[s]')
plt.title(f'Initial_Momentum: theta({init_state[2]:.1e}), dL({init_state[3]:.1e})', fontdict=font1)
plt.show()